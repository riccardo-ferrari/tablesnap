#!/usr/bin/env python

""" Cleans SSTables on S3 """

import argparse
import boto
import json
import logging
import os
import socket
import sys

from datetime import datetime
from dateutil import parser as dtparser

args = None
now = None

def days_ago(tstamp):
    global now
    if now is None:
        now = datetime.now()
    # Datetime format from the last_modified property on keys from boto
    backup = datetime.strptime(tstamp, '%Y-%m-%dT%H:%M:%S.%fZ')
    delta = now - backup
    return delta.days

def process_listdir(bucket, item):
    listdir_dict = {}
    if (days_ago(item.last_modified)> args.age):
        log.debug("Item: %s, has age %s, removing" % (item.name, days_ago(item.last_modified)))
        bucket.delete_key(item)
    else:
        ky = bucket.get_key(item)
        jdict = json.loads(ky.get_contents_as_string())
        if len(jdict.values()) != 1:
            raise SystemError('-listdir.json file should have '
                'a single key/value pair!')

        dirname = jdict.keys()[0]
        # fullpaths here since some files are in subdirectories
        fullpaths = [os.path.join(dirname, x) for x in jdict.values()[0]]
        for i in fullpaths:
            if listdir_dict.get(i) == None:
                listdir_dict[i] = 1
            else:
                listdir_dict[i] += 1
    return listdir_dict

def process_file_key(item):
    file_dict = {}
    if (days_ago(item.last_modified)> args.age):
        key = item.name.split(':')[1]
        file_dict[key] = item
    return file_dict

def inspect_list(bucket, item_list):
    item_count = 0
    listdir_delete_count = 0
    subfolders = []
    listdir_dict = {}
    file_dict = {}

    log.info("Processing: %s" % item_list.prefix)
    for item in item_list:
        item_count +=1

        if (item.name.endswith('/')):
            subfolders.append(item)
        elif (item.name.endswith('-listdir.json')):
            res = process_listdir(bucket, item)
            if len(res) == 0:
                listdir_delete_count +=1
            listdir_dict.update(res)
        else:
            file_dict.update(process_file_key(item))

        if (item_count % 5000) == 0:
            log.debug("Analyzed items progress: %s" % item_count)
            log.debug("\tReferenced listdir.json items: %s" % len(listdir_dict))
            log.debug("\tReferenced content file items: %s" % len(file_dict))

    log.info("Total items in fodler: %s" % item_count)
    log.info("Cleaning files:")
    content_deleted = 0
    for content in file_dict:
        keep_file = (args.keep_existing & os.path.isfile(content))

        if (listdir_dict.get(content) == None) and (not keep_file):
            log.debug('Deleting old file: %s with age: %s' % (content,days_ago(file_dict[content].last_modified))
            bucket.delete_key(file_dict[content])
            content_deleted += 1
    log.info('Removed %s entires', content_deleted)
    log.info("Process %s subfolders:" % len(subfolders))
    for sub in subfolders:
            inspect_list(bucket, bucket.list(prefix=sub.name, delimiter='/'))
    log.info("Leaving %s" % item_list.prefix)

def clean_backups(args, log):

    if args.debug:
        log.setLevel(logging.DEBUG)

    if not args.name:
        args.name = socket.getfqdn()

    try:
        s3conn = boto.connect_s3(aws_access_key_id=args.key,
                                 aws_secret_access_key=args.secret,
                                 security_token=args.token)
        bucket = s3conn.get_bucket(args.bucket)
    except boto.exception.BotoServerError, e:
        log.error('Problem initializing S3 connection: %s', e)
        sys.exit(1)

    log.info("Connected to S3, getting keys ...")

    lcs_prefix = "%s:%s" % (args.name, args.path)
    log.debug("Using prefix: %s", lcs_prefix)

    #According to the documentations keys are sent in alphabetical order
    # Beware that <filename>-10-<...> comes before than <filename>-9-<...>
    inspect_list(bucket, bucket.list(prefix=lcs_prefix, delimiter='/'))

    log.info("Keys deleted")

def main(log):
    global args
    parser = argparse.ArgumentParser(
        description='Clean SSTables from S3. Scroll backwards through '
        '-listdir.json keys in chronological order collecting a "keeper" '
        'list until it reaches it\'s age cutoff. Deletes all keys not in that '
        'list')
    parser.add_argument(
        '-d',
        '--debug',
        dest='debug',
        action='store_true',
        help='Run in debug mode, will not delete keys. Implies -v')
    parser.add_argument(
        '-l',
        '--list-deletes',
        dest='list_deletes',
        action='store_true',
        help='Log every file being deleted')
    parser.add_argument(
        '-e',
        '--keep-existing',
        dest='keep_existing',
        action='store_true',
        help='Keep files that still exist on this server regardless of age')
    parser.add_argument(
        '-k',
        '--key',
        dest='key',
        default=os.environ.get('AWS_ACCESS_KEY_ID'),
        help='Amazon S3 Key (default from AWS_ACCESS_KEY_ID in environment)')
    parser.add_argument(
        '-s',
        '--secret',
        dest='secret',
        default=os.environ.get('AWS_SECRET_ACCESS_KEY'),
        help='Amazon S3 Secret (default from AWS_SECRET_ACCESS_KEY in environment)')
    parser.add_argument('--token',
        default=os.environ.get('AWS_SECURITY_TOKEN'),
        help='Amazon S3 Token (default from AWS_SECURITY_TOKEN in environment)')
    parser.add_argument(
        '-n',
        '--name',
        dest='name',
        required=False,
        help='Use this name instead of the FQDN to identify the files from '
             'this host')
    parser.add_argument(
        'bucket',
        help='S3 Bucket')
    parser.add_argument(
        'path',
        help='Path portion of key in S3')
    parser.add_argument(
        'age',
        type=int,
        help='How many days worth of backups to keep')
    args = parser.parse_args()
    clean_backups(args, log)

if __name__ == '__main__':

    log = logging.getLogger('tablechop')
    stderr = logging.StreamHandler()
    stderr.setFormatter(logging.Formatter(
        '%(name)s [%(asctime)s] %(levelname)s %(message)s'))
    log.addHandler(stderr)
    if os.environ.get('TDEBUG', False):
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    main(log)
